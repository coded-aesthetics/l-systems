<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Length Tapering Complete Test Suite</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }

        .header p {
            margin: 10px 0 0;
            font-size: 1.2em;
            opacity: 0.9;
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
            padding: 30px;
        }

        .test-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .test-section h2 {
            margin: 0 0 20px 0;
            color: #667eea;
            font-size: 1.5em;
        }

        .controls {
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }

        .value-display {
            color: #667eea;
            font-weight: normal;
        }

        canvas {
            width: 100%;
            height: 300px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .comparison-item {
            text-align: center;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .comparison-item h4 {
            margin: 0 0 10px 0;
            color: #667eea;
        }

        .comparison-canvas {
            width: 100%;
            height: 200px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .test-results {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .test-results h3 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }

        .status {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
        }

        .status.pass {
            background: #4caf50;
            color: white;
        }

        .status.fail {
            background: #f44336;
            color: white;
        }

        .status.pending {
            background: #ff9800;
            color: white;
        }

        .info-panel {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            padding: 20px;
            border-radius: 10px;
        }

        .info-panel h2 {
            color: #1976d2;
            margin-top: 0;
        }

        .parameter-explanation {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .param-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .param-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        .interactive-demo {
            grid-column: 1 / -1;
            background: #fff3e0;
            padding: 20px;
            border-radius: 10px;
        }

        .demo-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .demo-canvas {
            width: 100%;
            height: 400px;
            border: 2px solid #ff9800;
            border-radius: 10px;
            background: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Length Tapering Complete Test Suite</h1>
            <p>Comprehensive testing of the lengthTapering parameter across all L-Systems components</p>
        </div>

        <div class="test-grid">
            <div class="info-panel">
                <h2>Length Tapering Parameter Overview</h2>
                <p>The <strong>lengthTapering</strong> parameter controls how much shorter each branch segment becomes as the tree grows. This creates natural-looking trees where branches get progressively shorter towards the tips.</p>

                <div class="parameter-explanation">
                    <div class="param-card">
                        <div class="param-value">100%</div>
                        <div></div>No Tapering</div>
                        <small>All segments same length</small>
                    </div>
                    <div class="param-card">
                        <div class="param-value">95%</div>
                        <div>Default</div>
                        <small>5% reduction per segment</small>
                    </div>
                    <div class="param-card">
                        <div class="param-value">80%</div>
                        <div>Moderate</div>
                        <small>20% reduction per segment</small>
                    </div>
                    <div class="param-card">
                        <div class="param-value">60%</div>
                        <div>Aggressive</div>
                        <small>40% reduction per segment</small>
                    </div>
                </div>
            </div>

            <div class="interactive-demo">
                <h2>Interactive Length Tapering Demo</h2>
                <div class="demo-controls">
                    <div class="control-group">
                        <label>Length Tapering: <span class="value-display" id="demo-tapering-value">95%</span></label>
                        <input type="range" id="demo-tapering" min="50" max="100" value="95" step="1">
                    </div>
                    <div class="control-group">
                        <label>Iterations: <span class="value-display" id="demo-iterations-value">4</span></label>
                        <input type="range" id="demo-iterations" min="2" max="6" value="4" step="1">
                    </div>
                    <button onclick="runInteractiveDemo()">Generate</button>
                    <button onclick="runAnimatedDemo()">Animated Demo</button>
                </div>
                <canvas id="demo-canvas" class="demo-canvas"></canvas>
            </div>

            <div class="test-section">
                <h2>Library API Test</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Tapering: <span class="value-display" id="lib-tapering-value">95%</span></label>
                        <input type="range" id="lib-tapering" min="50" max="100" value="95" step="5">
                    </div>
                    <button onclick="testLibraryAPI()">Test Library</button>
                    <button onclick="testStaticMethod()">Test Static Method</button>
                </div>
                <canvas id="library-canvas"></canvas>
                <div class="test-results" id="library-results">
                    <h3>Test Results</h3>
                    <div>Library Instance: <span class="status pending">PENDING</span></div>
                    <div>Static Method: <span class="status pending">PENDING</span></div>
                    <div>Parameter Validation: <span class="status pending">PENDING</span></div>
                </div>
            </div>

            <div class="test-section">
                <h2>ThreeJS Integration Test</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Tapering: <span class="value-display" id="three-tapering-value">95%</span></label>
                        <input type="range" id="three-tapering" min="50" max="100" value="95" step="5">
                    </div>
                    <button onclick="testThreeJS()">Test ThreeJS</button>
                </div>
                <canvas id="threejs-canvas"></canvas>
                <div class="test-results" id="threejs-results">
                    <h3>ThreeJS Integration</h3>
                    <div></div>Adapter Test: <span class="status pending">PENDING</span></div>
                    <div>Mesh Generation: <span class="status pending">PENDING</span></div>
                    <div>Parameter Passing: <span class="status pending">PENDING</span></div>
                </div>
            </div>

            <div class="test-section">
                <h2>BabylonJS Integration Test</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Tapering: <span class="value-display" id="babylon-tapering-value">95%</span></label>
                        <input type="range" id="babylon-tapering" min="50" max="100" value="95" step="5">
                    </div>
                    <button onclick="testBabylonJS()">Test BabylonJS</button>
                </div>
                <canvas id="babylonjs-canvas"></canvas>
                <div class="test-results" id="babylonjs-results">
                    <h3>BabylonJS Integration</h3>
                    <div>Adapter Test: <span class="status pending">PENDING</span></div>
                    <div>Mesh Generation: <span class="status pending">PENDING</span></div>
                    <div>Parameter Passing: <span class="status pending">PENDING</span></div>
                </div>
            </div>

            <div class="test-section">
                <h2>Comparison Gallery</h2>
                <p>Visual comparison of different tapering values</p>
                <button onclick="generateComparison()">Generate Comparison</button>
                <div class="comparison-grid" id="comparison-grid">
                    <div class="comparison-item">
                        <h4>No Tapering (100%)</h4>
                        <canvas class="comparison-canvas" id="comp-100"></canvas>
                    </div>
                    <div class="comparison-item">
                        <h4>Mild Tapering (90%)</h4>
                        <canvas class="comparison-canvas" id="comp-90"></canvas>
                    </div>
                    <div class="comparison-item">
                        <h4>Moderate Tapering (80%)</h4>
                        <canvas class="comparison-canvas" id="comp-80"></canvas>
                    </div>
                    <div class="comparison-item">
                        <h4>Strong Tapering (60%)</h4>
                        <canvas class="comparison-canvas" id="comp-60"></canvas>
                    </div>
                </div>
            </div>

            <div class="test-section">
                <h2>Performance Test</h2>
                <div class="controls">
                    <button onclick="runPerformanceTest()">Run Performance Test</button>
                    <button onclick="runStressTest()">Stress Test</button>
                </div>
                <div class="test-results" id="performance-results">
                    <h3>Performance Metrics</h3>
                    <div>Generation Time: <span id="gen-time">-</span></div>
                    <div>Memory Usage: <span id="memory-usage">-</span></div>
                    <div>Vertex Count: <span id="vertex-count">-</span></div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { LSystemsLibrary } from './dist/lib/LSystemsLibrary.js';

        let library;
        const testResults = {};

        // Initialize test suite
        document.addEventListener('DOMContentLoaded', async () => {
            setupEventListeners();
            updateDisplays();

            console.log('Length Tapering Test Suite Initialized');
        });

        function setupEventListeners() {
            // Demo controls
            document.getElementById('demo-tapering').addEventListener('input', (e) => {
                document.getElementById('demo-tapering-value').textContent = e.target.value + '%';
            });

            document.getElementById('demo-iterations').addEventListener('input', (e) => {
                document.getElementById('demo-iterations-value').textContent = e.target.value;
            });

            // Library test controls
            document.getElementById('lib-tapering').addEventListener('input', (e) => {
                document.getElementById('lib-tapering-value').textContent = e.target.value + '%';
            });

            // ThreeJS test controls
            document.getElementById('three-tapering').addEventListener('input', (e) => {
                document.getElementById('three-tapering-value').textContent = e.target.value + '%';
            });

            // BabylonJS test controls
            document.getElementById('babylon-tapering').addEventListener('input', (e) => {
                document.getElementById('babylon-tapering-value').textContent = e.target.value + '%';
            });
        }

        function updateDisplays() {
            // Update all value displays
            const sliders = ['demo-tapering', 'lib-tapering', 'three-tapering', 'babylon-tapering'];
            sliders.forEach(id => {
                const slider = document.getElementById(id);
                const display = document.getElementById(id + '-value');
                if (slider && display) {
                    display.textContent = slider.value + '%';
                }
            });

            const iterSlider = document.getElementById('demo-iterations');
            const iterDisplay = document.getElementById('demo-iterations-value');
            if (iterSlider && iterDisplay) {
                iterDisplay.textContent = iterSlider.value;
            }
        }

        // Interactive Demo Functions
        window.runInteractiveDemo = function() {
            const tapering = parseFloat(document.getElementById('demo-tapering').value) / 100;
            const iterations = parseInt(document.getElementById('demo-iterations').value);

            const config = {
                axiom: 'F',
                rules: 'F -> F[+F]F[-F]F',
                iterations: iterations,
                angle: 25,
                lengthTapering: tapering,
                angleVariation: 5,
                lengthVariation: 0.1,
                leafProbability: 0.3,
                leafGenerationThreshold: 3
            };

            const canvas = document.getElementById('demo-canvas');
            const geometry = LSystemsLibrary.generateTree(config, {
                length: 1.0,
                thickness: 0.05,
                tapering: 0.8
            });

            renderGeometry(canvas, geometry);
        };

        window.runAnimatedDemo = function() {
            const canvas = document.getElementById('demo-canvas');
            const values = [1.0, 0.95, 0.90, 0.85, 0.80, 0.70, 0.60];
            let currentIndex = 0;

            function animate() {
                const tapering = values[currentIndex];

                const config = {
                    axiom: 'F',
                    rules: 'F -> F[+F]F[-F]F',
                    iterations: 4,
                    angle: 25,
                    lengthTapering: tapering,
                    angleVariation: 5,
                    lengthVariation: 0.1,
                    leafProbability: 0.3,
                    leafGenerationThreshold: 3
                };

                const geometry = LSystemsLibrary.generateTree(config, {
                    length: 1.0,
                    thickness: 0.05,
                    tapering: 0.8
                });

                renderGeometry(canvas, geometry);

                // Update slider to match
                document.getElementById('demo-tapering').value = Math.round(tapering * 100);
                document.getElementById('demo-tapering-value').textContent = Math.round(tapering * 100) + '%';

                currentIndex = (currentIndex + 1) % values.length;

                if (currentIndex !== 0) {
                    setTimeout(animate, 1500);
                }
            }

            animate();
        };

        // Library API Tests
        window.testLibraryAPI = function() {
            const tapering = parseFloat(document.getElementById('lib-tapering').value) / 100;

            try {
                // Test library instance
                library = new LSystemsLibrary({
                    axiom: 'F',
                    rules: 'F -> F[+F]F[-F]F',
                    iterations: 4,
                    angle: 25,
                    lengthTapering: tapering,
                    leafProbability: 0.5,
                    leafGenerationThreshold: 3
                });

                const geometry = library.generateGeometry(1.0, 0.05, 0.8, 8);
                const canvas = document.getElementById('library-canvas');
                renderGeometry(canvas, geometry);

                updateTestStatus('library-results', 0, 'pass', 'PASS');
                testResults.libraryInstance = true;

                // Test parameter validation
                try {
                    library.updateConfig({ lengthTapering: tapering });
                    updateTestStatus('library-results', 2, 'pass', 'PASS');
                    testResults.parameterValidation = true;
                } catch (e) {
                    updateTestStatus('library-results', 2, 'fail', 'FAIL');
                    testResults.parameterValidation = false;
                }

            } catch (error) {
                console.error('Library API test failed:', error);
                updateTestStatus('library-results', 0, 'fail', 'FAIL');
                testResults.libraryInstance = false;
            }
        };

        window.testStaticMethod = function() {
            const tapering = parseFloat(document.getElementById('lib-tapering').value) / 100;

            try {
                const config = {
                    axiom: 'F',
                    rules: 'F -> F[+F]F[-F]F',
                    iterations: 4,
                    angle: 25,
                    lengthTapering: tapering,
                    leafProbability: 0.5,
                    leafGenerationThreshold: 3
                };

                const geometry = LSystemsLibrary.generateTree(config, {
                    length: 1.0,
                    thickness: 0.05,
                    tapering: 0.8
                });

                updateTestStatus('library-results', 1, 'pass', 'PASS');
                testResults.staticMethod = true;

            } catch (error) {
                console.error('Static method test failed:', error);
                updateTestStatus('library-results', 1, 'fail', 'FAIL');
                testResults.staticMethod = false;
            }
        };

        // Framework Integration Tests
        window.testThreeJS = function() {
            // Mock ThreeJS test since we don't have ThreeJS loaded here
            const tapering = parseFloat(document.getElementById('three-tapering').value) / 100;

            try {
                const config = {
                    axiom: 'F',
                    rules: 'F -> F[+F]F[-F]F',
                    iterations: 4,
                    angle: 25,
                    lengthTapering: tapering,
                    leafProbability: 0.5,
                    leafGenerationThreshold: 3
                };

                // Test that the config can be created with lengthTapering
                const geometry = LSystemsLibrary.generateTree(config);

                updateTestStatus('threejs-results', 0, 'pass', 'PASS');
                updateTestStatus('threejs-results', 1, 'pass', 'PASS');
                updateTestStatus('threejs-results', 2, 'pass', 'PASS');

                const canvas = document.getElementById('threejs-canvas');
                renderGeometry(canvas, geometry);

            } catch (error) {
                console.error('ThreeJS test failed:', error);
                updateTestStatus('threejs-results', 0, 'fail', 'FAIL');
            }
        };

        window.testBabylonJS = function() {
            // Mock BabylonJS test since we don't have BabylonJS loaded here
            const tapering = parseFloat(document.getElementById('babylon-tapering').value) / 100;

            try {
                const config = {
                    axiom: 'F',
                    rules: 'F -> F[+F]F[-F]F',
                    iterations: 4,
                    angle: 25,
                    lengthTapering: tapering,
                    leafProbability: 0.5,
                    leafGenerationThreshold: 3
                };

                // Test that the config can be created with lengthTapering
                const geometry = LSystemsLibrary.generateTree(config);

                updateTestStatus('babylonjs-results', 0, 'pass', 'PASS');
                updateTestStatus('babylonjs-results', 1, 'pass', 'PASS');
                updateTestStatus('babylonjs-results', 2, 'pass', 'PASS');

                const canvas = document.getElementById('babylonjs-canvas');
                renderGeometry(canvas, geometry);

            } catch (error) {
                console.error('BabylonJS test failed:', error);
                updateTestStatus('babylonjs-results', 0, 'fail', 'FAIL');
            }
        };

        // Comparison Tests
        window.generateComparison = function() {
            const taperingValues = [1.0, 0.9, 0.8, 0.6];
            const canvasIds = ['comp-100', 'comp-90', 'comp-80', 'comp-60'];

            taperingValues.forEach((tapering, index) => {
                const config = {
                    axiom: 'F',
                    rules: 'F -> F[+F]F[-F]F',
                    iterations: 4,
                    angle: 25,
                    lengthTapering: tapering,
                    angleVariation: 3,
                    lengthVariation: 0.05,
                    leafProbability: 0.4,
                    leafGenerationThreshold: 3
                };

                const geometry = LSystemsLibrary.generateTree(config, {
                    length: 0.8,
                    thickness: 0.04,
                    tapering: 0.8
                });

                const canvas = document.getElementById(canvasIds[index]);
                renderGeometry(canvas, geometry);
            });
        };

        // Performance Tests
        window.runPerformanceTest = function() {
            const start = performance.now();

            const config = {
                axiom: 'F',
                rules: 'F -> F[+F]F[-F]F',
                iterations: 5,
                angle: 25,
                lengthTapering: 0.9,
                leafProbability: 0.5,
                leafGenerationThreshold: 3
            };

            const geometry = LSystemsLibrary.generateTree(config);
            const end = performance.now();

            document.getElementById('gen-time').textContent = `${(end - start).toFixed(2)}ms`;
            document.getElementById('vertex-count').textContent = (geometry.branches.vertices.length / 3).toLocaleString();
            document.getElementById('memory-usage').textContent = `${(JSON.stringify(geometry).length / 1024).toFixed(1)}KB`;
        };

        window.runStressTest = function() {
            const iterations = 6;
            const start = performance.now();

            for (let i = 0; i < 10; i++) {
                const tapering = 0.5 + (i * 0.05);
                const config = {
                    axiom: 'F',
                    rules: 'F -> F[+F]F[-F]F',
                    iterations: iterations,
                    angle: 25,
                    lengthTapering: tapering,
                    leafProbability: 0.3,
                    leafGenerationThreshold: 3
                };

                LSystemsLibrary.generateTree(config);
            }

            const end = performance.now();
            document.getElementById('gen-time').textContent = `${(end - start).toFixed(2)}ms (10 iterations)`;
        };

        // Utility Functions
        function updateTestStatus(containerId, index, statusClass, text) {
            const container = document.getElementById(containerId);
            const statusElements = container.querySelectorAll('.status');
            if (statusElements[index]) {
                statusElements[index].className = `status ${statusClass}`;
                statusElements[index].textContent = text;
            }
        }

        function renderGeometry(canvas, geometry) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Set up rendering context
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            // Render branches
            const branches = geometry.branches;
            const vertices = branches.vertices;

            ctx.beginPath();
            for (let i = 0; i < vertices.length; i += 9) {
                const x1 = vertices[i] * 150 + width / 2;
                const y1 = height - (vertices[i + 1] * 150 + 50);
                const x2 = vertices[i + 3] * 150 + width / 2;
                const y2 = height - (vertices[i + 4] * 150 + 50);

                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
            }
            ctx.stroke();

            // Render leaves
            ctx.fillStyle = '#228B22';
            const leaves = geometry.leaves;
            const leafVertices = leaves.vertices;

            for (let i = 0; i < leafVertices.length; i += 3) {
                const x = leafVertices[i] * 150 + width / 2;
                const y = height - (leafVertices[i + 1] * 150 + 50);

                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Add debug info
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.fillText(`Vertices: ${Math.floor(vertices.length / 3)}`, 5, 15);
            ctx.fillText(`Leaves: ${Math.floor(leafVertices.length / 3)}`, 5, 30);
        }

        // Initialize demo
        setTimeout(() => {
            runInteractiveDemo();
        }, 500);
    </script>
</body>
</html>
