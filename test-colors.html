<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Parsing Debug Test</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            margin: 20px;
            background: #1a1a1a;
            color: #00ff00;
        }
        .output {
            background: #000;
            padding: 15px;
            border: 1px solid #333;
            margin: 10px 0;
            white-space: pre-wrap;
        }
        .error {
            color: #ff4444;
        }
        .success {
            color: #44ff44;
        }
        .info {
            color: #4488ff;
        }
        button {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        button:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <h1>ðŸ”¬ Color Parsing Debug Test</h</h1>1>

    <button onclick="testTokenParsing()">Test Token Parsing</button>
    <button onclick="testColorParsing()">Test Color Parsing</button>
    <button onclick="testRuleParsing()">Test Rule Parsing</button>
    <button onclick="testFullPipeline()">Test Full Pipeline</button>
    <button onclick="clearOutput()">Clear Output</button>

    <div class="output" id="output">Click a test button to begin...</div>

    <script type="module">
        // Import the compiled modules
        import { ParameterizedSymbolParser, LSystem } from './dist/LSystem.js';

        window.ParameterizedSymbolParser = ParameterizedSymbolParser;
        window.LSystem = LSystem;

        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : 'info';
            output.innerHTML += `[${timestamp}] <span class="${className}">${message}</span>\n`;
            output.scrollTop = output.scrollHeight;
        }

        window.clearOutput = function() {
            document.getElementById('output').innerHTML = '';
        };

        window.testTokenParsing = function() {
            log('=== TESTING TOKEN PARSING ===', 'info');

            const testStrings = [
                'F',
                'L{color:green}',
                'F{color:red}',
                'F{color:#FF0000}',
                'F{color:FABC34E4}',
                'F{color:red}[+L{color:green}][-L{color:blue}]',
                'L{color:green} -> L{color:autumn_orange}[+L{color:autumn_yellow}]'
            ];

            testStrings.forEach((testString, i) => {
                try {
                    log(`\nTest ${i + 1}: Parsing "${testString}"`, 'info');
                    const tokens = ParameterizedSymbolParser.parseString(testString);
                    log(`  Result: ${tokens.length} tokens`, 'success');

                    tokens.forEach((token, j) => {
                        log(`    Token ${j}: symbol="${token.symbol}"`, 'info');
                        if (token.parameters.size > 0) {
                            token.parameters.forEach((value, key) => {
                                log(`      ${key}: "${value}"`, 'info');
                            });
                        }
                    });

                    // Test reconstruction
                    const reconstructed = ParameterizedSymbolParser.tokensToString(tokens);
                    if (reconstructed === testString) {
                        log(`  âœ“ Reconstruction successful: "${reconstructed}"`, 'success');
                    } else {
                        log(`  âŒ Reconstruction failed: "${reconstructed}" != "${testString}"`, 'error');
                    }

                } catch (error) {
                    log(`  âŒ Error: ${error.message}`, 'error');
                }
            });
        };

        window.testColorParsing = function() {
            log('=== TESTING COLOR PARSING ===', 'info');

            const testColors = [
                'red', 'green', 'blue', 'brown',
                'leaf_green', 'bark_brown', 'dark_green',
                'autumn_red', 'autumn_orange', 'autumn_yellow',
                '#FF0000', '#00FF00', '#0000FF',
                'FF0000', '00FF00', '0000FF',
                'FABC34E4', 'FF000080',
                'invalid_color', '#ZZZ', 'notacolor'
            ];

            testColors.forEach((color, i) => {
                try {
                    log(`\nTest ${i + 1}: Parsing color "${color}"`, 'info');
                    const parsed = ParameterizedSymbolParser.parseColor(color);

                    if (parsed) {
                        log(`  âœ“ Result: [${parsed[0].toFixed(3)}, ${parsed[1].toFixed(3)}, ${parsed[2].toFixed(3)}, ${parsed[3].toFixed(3)}]`, 'success');
                    } else {
                        log(`  âŒ Failed to parse (returned null)`, 'error');
                    }
                } catch (error) {
                    log(`  âŒ Error: ${error.message}`, 'error');
                }
            });
        };

        window.testRuleParsing = function() {
            log('=== TESTING RULE PARSING ===', 'info');

            const testRules = [
                'F -> F[+F]F[-F]F',
                'F -> F{color:brown}[+L{color:green}]',
                'L{color:green} -> L{color:autumn_orange}[+L{color:autumn_yellow}]',
                'F -> F{color:#8B4513}[+L{color:#32CD32}][-L{color:#FF6347}]',
                'A -> F{color:brown}[&+A{color:red}][&-A{color:blue}][^+A{color:green}]'
            ];

            testRules.forEach((ruleText, i) => {
                try {
                    log(`\nTest ${i + 1}: Parsing rule "${ruleText}"`, 'info');
                    const rules = LSystem.parseRules(ruleText);
                    log(`  âœ“ Parsed ${rules.length} rules`, 'success');

                    rules.forEach((rule, j) => {
                        log(`    Rule ${j}: "${rule.from}" -> "${rule.to}"`, 'info');
                    });
                } catch (error) {
                    log(`  âŒ Error: ${error.message}`, 'error');
                }
            });
        };

        window.testFullPipeline = function() {
            log('=== TESTING FULL PIPELINE ===', 'info');

            const axiom = 'F';
            const ruleText = 'F -> F{color:red}[+L{color:green}]';

            try {
                log(`\n1. Testing axiom: "${axiom}"`, 'info');
                log(`2. Testing rule: "${ruleText}"`, 'info');

                // Parse rules
                const rules = LSystem.parseRules(ruleText);
                log(`3. âœ“ Parsed ${rules.length} rules`, 'success');

                // Create L-system
                const lsystem = new LSystem(axiom, rules, 25, 0, 0, 0.8, 3);
                log('4. âœ“ Created L-system', 'success');

                // Generate string
                const generated = lsystem.generate(1);
                log(`5. âœ“ Generated string: "${generated}"`, 'success');

                // Test if generation contains colors
                if (generated.includes('{color:')) {
                    log('6. âœ“ Generated string contains color parameters!', 'success');
                } else {
                    log('6. âŒ Generated string does NOT contain color parameters', 'error');
                }

                // Parse generated string
                const tokens = ParameterizedSymbolParser.parseString(generated);
                log(`7. âœ“ Parsed ${tokens.length} tokens from generated string`, 'success');

                let hasColors = false;
                tokens.forEach((token, j) => {
                    if (token.parameters.has('color')) {
                        hasColors = true;
                        const color = token.parameters.get('color');
                        log(`    Token ${j}: ${token.symbol} with color "${color}"`, 'success');
                    }
                });

                if (hasColors) {
                    log('8. âœ“ Found colored tokens in parsed result!', 'success');
                } else {
                    log('8. âŒ No colored tokens found in parsed result', 'error');
                }

                // Test geometry generation
                const geometry = lsystem.interpretToGeometry(generated, 1, 0.1, 0.8, [0.2, 0.8, 0.2]);
                log(`9. âœ“ Generated geometry with ${geometry.vertices.length / 3} vertices`, 'success');

                if (geometry.colors && geometry.colors.length > 0) {
                    log(`10. âœ“ Geometry has ${geometry.colors.length} color values!`, 'success');
                    log(`    First 8 colors: [${geometry.colors.slice(0, 8).map(v => v.toFixed(3)).join(', ')}]`, 'info');
                } else {
                    log('10. âŒ Geometry has no color data', 'error');
                }

                if (geometry.leafColors && geometry.leafColors.length > 0) {
                    log(`11. âœ“ Geometry has ${geometry.leafColors.length} leaf color values!`, 'success');
                } else {
                    log('11. âŒ Geometry has no leaf color data', 'error');
                }

            } catch (error) {
                log(`âŒ Pipeline failed: ${error.message}`, 'error');
                log(`Stack trace: ${error.stack}`, 'error');
            }
        };

        // Auto-run basic test on load
        setTimeout(() => {
            log('Color Parsing Debug Test Loaded', 'success');
            log('Click buttons above to run specific tests\n', 'info');
        }, 100);

    </script>
</body>
</html>
